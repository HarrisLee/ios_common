## 内存管理

### 概念

OC是使用引用计数来进行内存管理的，而且有了“自动引用计数（ARC）”之后，就更简单了。ARC几乎把所有内存管理事宜都交给编译器处理了，让开发者更专注于业务逻辑。

### 引用计数

OC使用引用计数来管理内存，就是说每个对象有个可以递增或递减的计数器。如果想使某个对象继续存活，就递增引用计数，用完之后，递减其计数。计数为0，就没人关注此对象了，就可以把它销毁。

注意，对象引用计数降为0，不一定会立即回收。因为对象所占的内存“解除分配（deallocated）”之后，只是放回“可用内存池”。如果在最后一层release之后对象没有被立即回收，或是被相同数据结构的对象重新利用，那么继续调用该对象不会发生错误。但是这只根据运行时情况而定，也可能会立即回收，继续调用对象发生崩溃。所以要避免这样做。

一般调用完release之后都会清空指针（将指针设置为nil），避免出现指向无效对象的指针（悬挂指针dangling pointer）。

### 属性设置方法中的内存管理

此方法保留新值，并释放旧值。顺序很重要，如果先释放旧值，再保留新值，而且两个值又指向同一个对象，那么先执行release就可能导致系统将此对象回收，于是实例变量变成了悬挂指针。

### 自动释放池

调用release会立刻递减对象的引用计数，然而有时候可以不用它，改为autorelease，此方法会在下一次“事件循环”时递减。

主要是为了下面这种情况：

```
- (NSString *)stringValue {
    NSString *str = [[NSString alloc] initWithFormat:@"why is autorelease"];
    return str;
}
```

该方法返回的str引用计数为1，这就要求调用者负责抵消多出来的计数，然而这是不合理的，因为调用者要清楚内部实现。

也不能在方法内释放str，否者方法还没返回，系统就把该对象回收了，返回的就是悬挂指针。

这时候就可以用autorelease，它会在稍后释放对象，给调用者足够的时间，使其在需要时保留返回值。此方法可以保证对象在跨越“方法调用边界”后一定存活。

### 内存泄漏

- 循环引用

### ARC


使用ARC时，引用计数实际上还是要执行的，只不过保留与释放操作由ARC自动为你添加。

由于ARC自动添加retain、release、autorelease方法，所以直接调用这些内存管理方法是非法的。

ARC需要方法命名规范，若方法以下面词语开头，则返回的对象贵调用者所有：

- alloc
- new
- copy
- mutableCopy

ARC默认，每个变量都是指向对象的强引用。

ARC清理实例变量，不需要像MRC一样在dealloc里面写释放实例变量的代码。

- ARC调用内存管理方法时，不通过普通的OC消息派发机制，而是直接调用底层C语言。这样性能更好，因为保留和释放操作需要频繁执行。
- 编译期，ARC把能够相互抵消的保留、释放操作简约。
- ARC运行期组件，某些方法返回之前执行了autorelease操作，而方法的调用者又对返回对象执行了保留操作，为了提升性能可将二者抵消。
- ARC只负责OC对象的内存。CoreFoundation对象不归ARC管理，需要适时调用CFRetain/CFRelease。






